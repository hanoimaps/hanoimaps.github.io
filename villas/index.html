<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Hanoi Maps | Villas</title>
    <link rel="manifest" href="/manifest.json" />

    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />

    <meta name="theme-color" content="#000000" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1,
    viewport-fit=cover"
    />
    <link rel="icon" type="image/x-icon" href="/favicon.ico" />
    <link
      href="https://unpkg.com/maplibre-gl@5.9.0/dist/maplibre-gl.css"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/maplibre-gl@5.9.0/dist/maplibre-gl.js"></script>
    <link rel="stylesheet" href="/villas/villas.css" />
  </head>
  <body>
    <div id="map"></div>
    <!--  POPUP -->
    <div id="menu-popup" class="menu-popup">
      <p>
        1216 biệt thự theo quyết định
        <a
          href="https://thuvienphapluat.vn/van-ban/Bat-dong-san/Quyet-dinh-1845-QD-UBND-2022-Danh-muc-nha-biet-thu-cu-Ha-Noi-truoc-1954-516094.aspx"
          target="_blank"
          >1845/2022</a
        >
        UBND TP. Hà Nội.
      </p>
      <ul>
        <li>1: Phải giữ nguyên hiện trạng</li>
        <li>2: Phải giữ nguyên nét gốc</li>
        <li>3: Được thay đổi hiện trạng</li>
        <li>?: Chưa có trong danh sách</li>
      </ul>
    </div>

    <script type="module">
      import {
        STREETS_STYLE,
        SATELLITE_HYBRID_STYLE,
        StyleSwitcherControl,
        modifyBaseStyle,
      } from "../shared.js";

      // --- 1. CONSTANTS ---
      const DATA_URL = "data.json";
      const SOURCE_ID = "villa-points-source";
      const UNCLUSTERED_LAYER_ID = "unclustered-point";
      const CLUSTERING_ENABLED = false;

      const menuPopup = document.getElementById("menu-popup");

      let globalGeojsonData = null;

      // --- 2. CONFIG ---
      const map = new maplibregl.Map({
        container: "map",
        style: STREETS_STYLE,
        center: [105.8542, 21.0285],
        zoom: 12,
        maxZoom: 24,
        maxBounds: [
          [105.5, 20.7],
          [106.1, 21.5],
        ],
        attributionControl: false,
      });

      map.on("styledata", () => {
        if (globalGeojsonData && !map.getSource(SOURCE_ID)) {
          applyCustomStylesAndLayers(globalGeojsonData);
        }
      });

      // 2.1: Use 'load' for utils
      map.on("load", async () => {
        map.addControl(
          new maplibregl.NavigationControl({
            visualizePitch: true,
          }),
          "top-left"
        );
        map.addControl(
          new maplibregl.GeolocateControl({
            positionOptions: { enableHighAccuracy: true },
            trackUserLocation: true,
          }),
          "top-left"
        );

        map.addControl(
          new StyleSwitcherControl({
            streets: STREETS_STYLE,
            satellite: SATELLITE_HYBRID_STYLE,
          }),
          "top-left"
        );

        map.addControl(new MenuControl(), "top-left");

        map.addControl(
          new maplibregl.AttributionControl({
            customAttribution:
              '<a href="https://threads.com/@tomeyinhanoi" target="_blank" style="text-decoration: underline">By Tomey</a> | <a href="https://thuvienphapluat.vn/van-ban/Bat-dong-san/Quyet-dinh-1845-QD-UBND-2022-Danh-muc-nha-biet-thu-cu-Ha-Noi-truoc-1954-516094.aspx" target="_blank"  style="text-decoration: underline">Sources</a>',
            compact: true,
          }),
          "bottom-left"
        );

        const compass = document.querySelector(".maplibregl-ctrl-compass");
        if (compass) {
          compass.style.display = "none";
          const toggleCompass = () => {
            compass.style.display =
              Math.abs(map.getBearing()) > 0.1 ? "block" : "none";
          };
          map.on("rotate", toggleCompass);
          map.on("moveend", toggleCompass);
          toggleCompass();
        }

        try {
          globalGeojsonData = await loadAndParseData(DATA_URL);
          applyCustomStylesAndLayers(globalGeojsonData);
        } catch (error) {
          console.error(
            "Error during initial data load and layer application:",
            error
          );
        }
      });

      function applyCustomStylesAndLayers(geojsonData) {
        modifyBaseStyle(map); // 3.1
        addDataLayer(map, geojsonData); // 3.3
        addInteractivity(map); // 3.4
      }

      class MenuControl {
        onAdd(map) {
          this._map = map;
          this._container = document.createElement("div");
          this._container.className = "maplibregl-ctrl maplibregl-ctrl-group";

          const button = document.createElement("button");
          button.className = "maplibregl-ctrl-icon maplibregl-ctrl-menu";
          button.type = "button";
          button.setAttribute("aria-label", "Open menu");

          button.onclick = (e) => {
            e.stopPropagation();
            menuPopup.classList.toggle("active");
          };

          this._container.appendChild(button);
          this._container.appendChild(menuPopup);
          return this._container;
        }

        onRemove() {
          this._container.parentNode.removeChild(this._container);
          this._map = undefined;
        }
      }

      // 2.2: Caching
      function registerServiceWorker() {
        if ("serviceWorker" in navigator) {
          window.addEventListener("load", () => {
            navigator.serviceWorker
              .register("./sw.js", { scope: "./" })
              .then((registration) => {
                console.log(
                  "ServiceWorker registration successful with scope: ",
                  registration.scope
                );
              })
              .catch((error) => {
                console.log("ServiceWorker registration failed: ", error);
              });
          });
        }
      }
      registerServiceWorker();

      // 2.3: Use 'idle' for main workflow.
      // map.once("idle", mainWorkflow);

      // --- 3. WORKFLOW ---
      // async function mainWorkflow() {
      // try {
      // modifyBaseStyle(map); // 3.1
      // globalGeojsonData = await loadAndParseData(DATA_URL); // 3.2
      // addDataLayer(map, geojsonData); // 3.3
      // addInteractivity(map); // 3.4
      //   } catch (error) {
      //     console.error("Error:", error);
      //   }
      // }

      // 3.2: Load GeoJSON
      async function loadAndParseData(url) {
        return new Promise((resolve, reject) => {
          const worker = new Worker("./webworker.js");
          worker.onmessage = (e) => {
            worker.terminate(); // Stop the worker when done
            if (e.data.error) {
              reject(new Error(e.data.error));
            } else {
              resolve(e.data.data);
            }
          };

          worker.onerror = (e) => {
            worker.terminate();
            reject(
              new Error(`Web Worker failed to start or execute: ${e.message}`)
            );
          };

          worker.postMessage({ url });
        });
      }

      // 3.3: Data layers
      function addDataLayer(map, geojsonData) {
        const firstSymbolId = map
          .getStyle()
          .layers.find((layer) => layer.type === "symbol")?.id;

        [
          "clusters",
          "cluster-count",
          UNCLUSTERED_LAYER_ID,
          "house-type-labels",
        ].forEach((id) => {
          if (map.getLayer(id)) map.removeLayer(id);
        });
        if (map.getSource(SOURCE_ID)) map.removeSource(SOURCE_ID);

        const sourceOptions = {
          type: "geojson",
          data: geojsonData,
        };

        if (CLUSTERING_ENABLED) {
          sourceOptions.cluster = true;
          sourceOptions.clusterMaxZoom = 16;
          sourceOptions.clusterRadius = 50;
        }

        map.addSource(SOURCE_ID, sourceOptions);

        if (CLUSTERING_ENABLED) {
          // 1st layer: clusters
          map.addLayer({
            id: "clusters",
            type: "circle",
            source: SOURCE_ID,
            filter: ["has", "point_count"],
            paint: {
              "circle-color": [
                "step",
                ["get", "point_count"],
                "#51bbd6",
                100,
                "#f1f075",
                750,
                "#f28cb1",
              ],
              "circle-radius": [
                "step",
                ["get", "point_count"],
                20,
                100,
                30,
                750,
                40,
              ],
            },
          });

          // 2nd layer: cluster number
          map.addLayer({
            id: "cluster-count",
            type: "symbol",
            source: SOURCE_ID,
            filter: ["has", "point_count"],
            layout: {
              "text-field": "{point_count_abbreviated}",
              "text-font": ["Roboto Regular", "Arial Unicode MS Regular"],
              "text-size": 12,
            },
          });
        }

        // 3rd layer: unclustered points
        map.addLayer({
          id: UNCLUSTERED_LAYER_ID,
          type: "circle",
          source: SOURCE_ID,
          filter: ["!", ["has", "point_count"]], // Only apply to features that are NOT clusters
          paint: {
            "circle-color": "#FF5722",
            "circle-radius": [
              "interpolate",
              ["linear"],
              ["zoom"],
              15,
              5,
              22,
              24,
            ],
            "circle-stroke-width": 1,
            "circle-stroke-color": "#fff",
          },
        });

        // 4th layer: Unclustered point type number
        const unclusteredLayerLabels = {
          id: "house-type-labels",
          type: "symbol",
          source: SOURCE_ID,
          minzoom: 15.5,
          layout: {
            "text-field": ["get", "type"],
            "text-font": ["Roboto Regular", "Arial Unicode MS Regular"],
            "text-size": 12,
            "text-allow-overlap": false,
          },
          paint: {
            "text-color": "#ffffff",
          },
        };

        if (CLUSTERING_ENABLED) {
          // unclusteredLayer.filter = ["!", ["has", "point_count"]];
          unclusteredLayerLabels.filter = ["!", ["has", "point_count"]];
        }

        // map.addLayer(unclusteredLayer, firstSymbolId);
        map.addLayer(unclusteredLayerLabels, firstSymbolId);
      }

      // 3.4: Interactions
      function addInteractivity(map) {
        // Popup for unclustered points
        map.on("click", UNCLUSTERED_LAYER_ID, (e) => {
          const props = e.features[0].properties;
          const coords = e.features[0].geometry?.coordinates;
          const markerId = props.id;
          console.log(markerId);
          if (props?.address && coords) {
            const googleMapsUrl = `https://www.google.com/maps/place/${encodeURIComponent(
              props.address
            )}`;

            const popupHTML = `
                  <b>${props.address}</b>
                  <a href="${googleMapsUrl}" target="_blank">
                    Google Maps
                  </a>
                `;

            if (window.currentPopup) window.currentPopup.remove();

            map.flyTo({
              center: coords,
              zoom: map.getZoom(),
              duration: 900,
              curve: 1.42,
              essential: true,
            });

            setTimeout(() => {
              window.currentPopup = new maplibregl.Popup({
                closeButton: false,
                focusAfterOpen: false,
                anchor: "bottom",
              })
                .setLngLat(coords)
                .setHTML(popupHTML)
                .addTo(map);
            }, 600);
          }
        });

        map.on("click", () => {
          if (menuPopup.classList.contains("active")) {
            menuPopup.classList.remove("active");
          }
        });

        map.on("mouseenter", UNCLUSTERED_LAYER_ID, () => {
          map.getCanvas().style.cursor = "pointer";
        });
        map.on("mouseleave", UNCLUSTERED_LAYER_ID, () => {
          map.getCanvas().style.cursor = "default";
        });

        if (CLUSTERING_ENABLED) {
          // Click clusters to zooms in
          map.on("click", "clusters", (e) => {
            const features = map.queryRenderedFeatures(e.point, {
              layers: ["clusters"],
            });
            if (!features.length) {
              return;
            }
            const cluster = features[0];
            const pointCount = cluster.properties.point_count;
            if (pointCount <= 5) {
              const clusterId = cluster.properties.cluster_id;
              map
                .getSource(SOURCE_ID)
                .getClusterExpansionZoom(clusterId, (err, zoom) => {
                  if (err) return;
                  map.flyTo({
                    center: cluster.geometry.coordinates,
                    zoom: zoom,
                    speed: 0.6,
                    duration: 1700,
                  });
                });
            }
          });

          // Cursor = pointer
          map.on("mouseenter", "clusters", () => {
            map.getCanvas().style.cursor = "pointer";
          });
          map.on("mouseleave", "clusters", () => {
            map.getCanvas().style.cursor = "default";
          });
        }
      }
    </script>
  </body>
</html>
